## Positioning

library(tidyverse)

#### Facets ####

# There are three types of facets
# 1. facet_null(): a single plot, the default
# 2. facet_wrap(): 'wraps' a 1d ribbon of panels into 2d
# 3. facet_grid(): produces a 2d grid of panels defined by variables which form the rows and columns

# facets have the potential to take a lot of space so we will subset our data
# three cylindders (4, 6, 8)
# two types of drive train (4 and f)
# six classes

mpg2 <- subset(mpg, cyl != 5 & drv %in% c('4', 'f') & class != '2seater')
mpg2 <- 
  mpg %>% 
  filter(cyl != 5, drv %in% c('4', 'f'), class != '2seater') 


## facet_wrap
# facet_wrap() creates a ribbon of panels (generated by the number of variables)
# and wraps it into 2d

# You can control how the ribbon is wrapped into a grid with 
# ncol, nrow: control how many columns or rows - only one is needed
# as.table: controls whether the facets are laid out like a table 
#           (TRUE), with the highest values at the bottom right or
#           (FALSE), with the highest values at the top right
# dir: controls the direction of the wrap: [h]orizontal or [v]ertical

base <- ggplot(mpg2, aes(displ, hwy)) + 
  geom_blank() + 
  xlab(NULL) + 
  ylab(NULL)

base + facet_wrap(~class, ncol = 3)
base + facet_wrap(~class, ncol = 3, as.table = F)

## facet_grid
# facet_grid lays out plots in a 2d grid

# . ~ a
# spreads the values of a across the columns.  This direction facilitates comparisons of the y position
# since the vertical scales are alligned

# b ~ .
# spreads the values of b down the rows.  This direction facilitates comparisons of x position 
# because the horizontal scales are aligned
# This makes it useful for comparing distributions

base + facet_grid(. ~ cyl)
base + facet_grid(drv ~ .)

# a ~ b
# spreads a across columns and b down rows.  Usually put the variable with the greater number on columns
# to take advantage of the spect ration of your screen

base + facet_grid(drv ~ cyl)

## You can use multiple variables in the rows or columns by "adding" them
# e.g. a + b ~ c + d
# variables appearing together on the rows or columns are nested in the sense that 
# only combinations that appear in the data will appear in the plot
# Variables that are specified on rows and columns will be crossed: all combinations will be shown
# including those that didn't appear in the original dataset: this may result in empty panels


#### Controlling Scales ####
# for both facets you can control whether the position scales are the same in all panels or allowed to vary

# scales = 'fiexed': x and y scales are fiexed across all panels
# scales = 'free_x': x scale is free, y is fixed
# sclaes = 'free_y': x scale is fixed, y is free
# scales = 'free': both scales are free

# facet_grid imposes an additional constraint on the scales:
# all panels in a column must have the same x sale and all panels in a row must have the same y scale
# This is because each column shares an x axis and each row shares a y axis

# fixed scales make it easier to see patterns accross panels
# free scales make it easier to see patterns within panels

p <- ggplot(mpg2, aes(cty, hwy)) + 
  geom_abline() + 
  geom_jitter(width = 0.1, height = 0.1)

p + facet_wrap(~cyl)
p + facet_wrap(~cyl, scales = 'free')


economics_long %>% 
  ggplot(aes(x = date, y = value)) + 
  geom_line() + 
  facet_wrap(~variable, scales = 'free_y', ncol=1)

# facet_grid has an additional parameter called space
# space thakes the same values as sacales.  When space = 'free', 
# each column (or row) will have width (or height) 
# proportional to the range of the scale for that column (or row)

# For example if panel a had range 2 and panel b had range 4
# panel a would take up 1/3 space and panel b would take upt 2/3 space

mpg2$model <- reorder(mpg2$model, mpg2$cty)
mpg2$manufacturer <- reorder(mpg2$manufacturer, -mpg2$cty)

ggplot(mpg2, aes(cty, model)) + 
  geom_point() +
  facet_grid(manufacturer ~ ., scales = 'free', space = 'free') + 
  theme(strip.text.y = element_text(angle = 0))

#### Missing Facet Variables ####

# What happens when you want to facet multiple datasets, but one dataset doesn't have 
# The variable you want to facet by?

# ggplot2 will do what you expect:
# it will display the map in every facet: missing facetting variables are treated
# like they have all values

df1 <- data.frame(x = 1:3, y = 1:3, gender = c("f", "f", "m"))
df2 <- data.frame(x = 2, y = 2)

ggplot(df1, aes(x, y)) +
  geom_point(data = df2, colour = "red", size = 2) +
  geom_point() +
  facet_wrap(~gender)

# ggplot2 has put the red point in both graphs


#### Grouping vs. Facetting ####

# Using faceting is another way of adding aesthetics like color, shape or size
# Both have strengths and weaknesses

# With facetting, each group is quite far apart in its own panel,
# and there is no overlap between the groups.
# This is good if the groups overlap a lot, but it does make small differences
# harder to see. 
# 
# When using aesthetics to differentiate groups, the groups are
# close together and may overlap, but small differences are easier to see.

df <- data.frame(
  x = rnorm(120, c(0, 2, 4)),
  y = rnorm(120, c(1, 2, 1)),
  z = letters[1:3]
)

ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z))

ggplot(df, aes(x, y)) +
  geom_point() +
  facet_wrap(~z)

# Comparisons between facets often benefit from some thoughtful annotation. For example, 
# in this case we could show the mean of each group in every panel. 

df_sum <- df %>%
  group_by(z) %>%
  summarise(x = mean(x), y = mean(y)) %>%
  rename(z2 = z)

ggplot(df, aes(x, y)) +
  geom_point() +
  geom_point(data = df_sum, aes(colour = z2), size = 4) +
  facet_wrap(~z)

df2 <- df %>% select(-z)

ggplot(df, aes(x, y)) +
  geom_point(data = df2, color = "grey70") +
  geom_point(aes(color = z)) +
  facet_wrap(~z) 


#### Continuous Variables ####

# To facet continuous variables, you must first discretise them. ggplot2 provides
# three helper functions to do so:
#   • Divide the data into n bins each of the same length: cut_interval(x, n)
#   • Divide the data into bins of width width: cut_width(x, width).
#   • Divide the data into n bins each containing (approximately) the same
#     number of points: cut_number(x, n = 10).

# Bins of width 1
mpg2$disp_w <- cut_width(mpg2$displ, 1)

# Six bins of equal length
mpg2$disp_i <- cut_interval(mpg2$displ, 6)

# Six bins containing equal numbers of points
mpg2$disp_n <- cut_number(mpg2$displ, 6)

plot <- ggplot(mpg2, aes(cty, hwy)) +
  geom_point() +
  labs(x = NULL, y = NULL)

plot + facet_wrap(~disp_w, nrow = 1)
plot + facet_wrap(~disp_i, nrow = 1)
plot + facet_wrap(~disp_n, nrow = 1)

#### Coordinate Systems ####

# There are two types of coordinate system. Linear coordinate systems preserve the shape of geoms:
#   • coord cartesian(): the default Cartesian coordinate system, where the 2d
#     position of an element is given by the combination of the x and y positions.
#   • coord flip(): Cartesian coordinate system with x and y axes flipped.
#   • coord fixed(): Cartesian coordinate system with a fixed aspect ratio.

# On the other hand, non-linear coordinate systems can change the shapes:
# a straight line may no longer be straight. The closest distance between two
# points may no longer be a straight line.
#   • coord map()/coord quickmap(): Map projections.
#   • coord polar(): Polar coordinates.
#   • coord trans(): Apply arbitrary transformations to x and y positions, after
#     the data has been processed by the stat.


#### Zooming into a Plot with coord cartesian() ####


# The key difference is how the limits work: when setting scale limits, 
# any data outside the limits is thrown away; but when setting coordinate system limits we
# still use all the data, but we only display a small region of the plot. 
# Setting coordinate system limits is like looking at the plot under a magnifying glass.

base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth()

# Full dataset
base

# Scaling to 5--7 throws away data outside that range
base + scale_x_continuous(limits = c(5, 7))
#> Warning: Removed 196 rows containing non-finite values (stat_smooth)
#> Warning: Removed 196 rows containing missing values (geom_point).

# Zooming to 5--7 keeps all the data but only shows some of it
base + coord_cartesian(xlim = c(5, 7))



#### Equal Scales with coord fixed() ####

# coord fixed() fixes the ratio of length on the x and y axes. The default ratio
# ensures that the x and y axes have equal scales: i.e., 1 cm along the x axis
# represents the same range of data as 1 cm along the y axis. The aspect ratio
# will also be set to ensure that the mapping is maintained regardless of the
# shape of the output device. See the documentation of coord fixed() for more details.


#### Non-linear Coordinate Systems ####

# Unlike linear coordinates, non-linear coordinates can change the shape of
# geoms. For example, in polar coordinates a rectangle becomes an arc; in a
# map projection, the shortest path between two points is not necessarily a
# straight line. The code below shows how a line and a rectangle are rendered
# in a few different coordinate systems.

rect <- data.frame(x = 50, y = 50)
line <- data.frame(x = c(1, 200), y = c(100, 1))
base <- ggplot(mapping = aes(x, y)) +
  geom_tile(data = rect, aes(width = 50, height = 50)) +
  geom_line(data = line) +
  xlab(NULL) + ylab(NULL)

base
base + coord_polar("x")
base + coord_polar("y")

base + coord_flip()
base + coord_trans(y = "log10")
base + coord_fixed()


# The transformation takes part in two steps. Firstly, the parameterisation
# of each geom is changed to be purely location-based, rather than locationand 
# dimension-based. For example, a bar can be represented as an x position
# (a location), a height and a width (two dimensions). Interpreting height and
# width in a non-Cartesian coordinate system is hard because a rectangle may
# no longer have constant height and width, so we convert to a purely locationbased 
# representation, a polygon defined by the four corners. This effectively
# converts all geoms to a combination of points, lines and polygons.

# Once all geoms have a location-based representation, the next step is to
# transform each location into the new coordinate system. It is easy to transform points,
# because a point is still a point no matter what coordinate system you are in. Lines and 
# polygons are harder, because a straight line may
# no longer be straight in the new coordinate system. To make the problem
# tractable we assume that all coordinate transformations are smooth, in the
# sense that all very short lines will still be very short straight lines in the new
# coordinate system. With this assumption in hand, we can transform lines and
# polygons by breaking them up into many small line segments and transforming each segment. 
# This process is called munching and is illustrated below:

# 1. We start with a line parameterised by its two endpoints:
df <- data.frame(r = c(0, 1), theta = c(0, 3 / 2 * pi))
ggplot(df, aes(r, theta)) +
  geom_line() +
  geom_point(size = 2, colour = "red")

# 2. We break it into multiple line segments, each with two endpoints.
interp <- function(rng, n) {
  seq(rng[1], rng[2], length = n)
}
munched <- data.frame(
  r = interp(df$r, 15),
  theta = interp(df$theta, 15)
)
ggplot(munched, aes(r, theta)) +
  geom_line() +
  geom_point(size = 2, colour = "red")

# 3. We transform the locations of each piece:
transformed <- transform(
  munched,
  x = r * sin(theta),
  y = r * cos(theta)
)

ggplot(transformed, aes(x, y)) +
  geom_path() +
  geom_point(size = 2, colour = "red") +
  coord_fixed()

# Internally ggplot2 uses many more segments so that the result looks smooth.


#### Polar Coordinates with coord polar() ####


# Using polar coordinates gives rise to pie charts and wind roses (from bar
# geoms), and radar charts (from line geoms). 

# Polar coordinates are often used
# for circular data, particularly time or direction, but the perceptual properties
# are not good because the angle is harder to perceive for small radii than it
# is for large radii. The theta argument determines which position variable is
# mapped to angle (by default, x) and which to radius.
# The code below shows how we can turn a bar into a pie chart or a bullseye
# chart by changing the coordinate system. The documentation includes other
# examples.

base <- ggplot(mtcars, aes(factor(1), fill = factor(cyl))) +
  geom_bar(width = 1) +
  theme(legend.position = "none") +
  scale_x_discrete(NULL, expand = c(0, 0)) +
  scale_y_continuous(NULL, expand = c(0, 0))

# Stacked barchart
base

# Pie chart
base + coord_polar(theta = "y")

# The bullseye chart
base + coord_polar()




#### Map Projections with coord map() ####

# Maps are intrinsically displays of spherical data. Simply plotting raw longitudes and latitudes 
# is misleading, so we must project the data. 

# There are two ways to do this with ggplot2:
#   • coord quickmap() is a quick and dirty approximation that sets the aspect
#     ratio to ensure than 1m of latitude and 1m of longitude are the same
#     distance in the middle of the plot. This is a reasonable place to start for
#     smaller regions, and is a lot faster.

# Prepare a map of NZ
nzmap <- ggplot(map_data("nz"), aes(long, lat, group = group)) +
  geom_polygon(fill = "white", colour = "black") +
  xlab(NULL) + ylab(NULL)

# Plot it in cartesian coordinates
nzmap

# With the aspect ratio approximation
nzmap + coord_quickmap()

# • coord_map() uses the mapproj package, https://cran.r-project.org/
#   package=mapproj to do a formal map projection. 
#   It takes the same arguments as mapproj::mapproject() for controlling the projection. 
#   It is much slower than coord_quickmap() because it must munch the data and transform each piece.

world <- map_data("world")
worldmap <- ggplot(world, aes(long, lat, group = group)) +
  geom_path() +
  scale_y_continuous(NULL, breaks = (-2:3) * 30, labels = NULL) +
  scale_x_continuous(NULL, breaks = (-4:4) * 45, labels = NULL)

worldmap + coord_map()

# Some crazier projections
worldmap + coord_map("ortho")
worldmap + coord_map("stereographic")
